#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GT_Bodycam

#include "Basic.hpp"

#include "GT_Bodycam_classes.hpp"
#include "GT_Bodycam_parameters.hpp"


namespace SDK
{

// Function GT_Bodycam.GT_Bodycam_C.AddVoteNextMap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_VoteNextMapInfo&      VoteInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::AddVoteNextMap(const struct FSTR_VoteNextMapInfo& VoteInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "AddVoteNextMap");

	Params::GT_Bodycam_C_AddVoteNextMap Parms{};

	Parms.VoteInfo = std::move(VoteInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.AIListInTeam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSTR_PCInfo>&             Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// TArray<struct FSTR_PCInfo>*             AIArrayReturn                                          (Parm, OutParm, ContainsInstancedReference)
// TArray<struct FSTR_PCInfo>*             PlayerArrayReturn                                      (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::AIListInTeam(TArray<struct FSTR_PCInfo>& Team, TArray<struct FSTR_PCInfo>* AIArrayReturn, TArray<struct FSTR_PCInfo>* PlayerArrayReturn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "AIListInTeam");

	Params::GT_Bodycam_C_AIListInTeam Parms{};

	Parms.Team = std::move(Team);

	UObject::ProcessEvent(Func, &Parms);

	Team = std::move(Parms.Team);

	if (AIArrayReturn != nullptr)
		*AIArrayReturn = std::move(Parms.AIArrayReturn);

	if (PlayerArrayReturn != nullptr)
		*PlayerArrayReturn = std::move(Parms.PlayerArrayReturn);
}


// Function GT_Bodycam.GT_Bodycam_C.AllowedLevels
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::AllowedLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "AllowedLevels");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.AnyBombExist
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABombe_C**                        Bomb_0                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::AnyBombExist(class ABombe_C** Bomb_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "AnyBombExist");

	Params::GT_Bodycam_C_AnyBombExist Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Bomb_0 != nullptr)
		*Bomb_0 = Parms.Bomb_0;
}


// Function GT_Bodycam.GT_Bodycam_C.BombIsActive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABombe_C*                         Bomb_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   BombActive_                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::BombIsActive(class ABombe_C* Bomb_0, bool* BombActive_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "BombIsActive");

	Params::GT_Bodycam_C_BombIsActive Parms{};

	Parms.Bomb_0 = Bomb_0;

	UObject::ProcessEvent(Func, &Parms);

	if (BombActive_ != nullptr)
		*BombActive_ = Parms.BombActive_;
}


// Function GT_Bodycam.GT_Bodycam_C.Bots Method?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Bots_Method                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Bots_Method_(bool* Bots_Method)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Bots Method?");

	Params::GT_Bodycam_C_Bots_Method_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Bots_Method != nullptr)
		*Bots_Method = Parms.Bots_Method;
}


// Function GT_Bodycam.GT_Bodycam_C.BPI Get Inventory
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventory_C**                    Inventory                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::BPI_Get_Inventory(class UInventory_C** Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "BPI Get Inventory");

	Params::GT_Bodycam_C_BPI_Get_Inventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Inventory != nullptr)
		*Inventory = Parms.Inventory;
}


// Function GT_Bodycam.GT_Bodycam_C.BreakTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::BreakTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "BreakTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.CalcTeamKillTotal
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  MilitaryKill_Return                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TerroristKill_Return                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Team*                                 Team_Win                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::CalcTeamKillTotal(int32* MilitaryKill_Return, int32* TerroristKill_Return, E_Team* Team_Win)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "CalcTeamKillTotal");

	Params::GT_Bodycam_C_CalcTeamKillTotal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MilitaryKill_Return != nullptr)
		*MilitaryKill_Return = Parms.MilitaryKill_Return;

	if (TerroristKill_Return != nullptr)
		*TerroristKill_Return = Parms.TerroristKill_Return;

	if (Team_Win != nullptr)
		*Team_Win = Parms.Team_Win;
}


// Function GT_Bodycam.GT_Bodycam_C.CanCreateKickVote
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CanCreateKickVote_                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::CanCreateKickVote(bool* CanCreateKickVote_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "CanCreateKickVote");

	Params::GT_Bodycam_C_CanCreateKickVote Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanCreateKickVote_ != nullptr)
		*CanCreateKickVote_ = Parms.CanCreateKickVote_;
}


// Function GT_Bodycam.GT_Bodycam_C.CanKickThisPlayer?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    PlayerId                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   True_                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::CanKickThisPlayer_(const class FString& PlayerId, bool* True_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "CanKickThisPlayer?");

	Params::GT_Bodycam_C_CanKickThisPlayer_ Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);

	if (True_ != nullptr)
		*True_ = Parms.True_;
}


// Function GT_Bodycam.GT_Bodycam_C.ClearMap
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::ClearMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ClearMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.DeseableTk (Multicast)
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::DeseableTk__Multicast_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "DeseableTk (Multicast)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.EndVoteNextMap
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::EndVoteNextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "EndVoteNextMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Event Ragdoll End
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Event_Ragdoll_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Event Ragdoll End");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.EventRagdollStart
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::EventRagdollStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "EventRagdollStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.ExecuteUbergraph_GT_Bodycam
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::ExecuteUbergraph_GT_Bodycam(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ExecuteUbergraph_GT_Bodycam");

	Params::GT_Bodycam_C_ExecuteUbergraph_GT_Bodycam Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Find Best Spawn Point
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               PCInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FTransform*                      FarestTransform_return                                 (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Find_Best_Spawn_Point(const struct FSTR_PCInfo& PCInfo, struct FTransform* FarestTransform_return, bool* Success_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Find Best Spawn Point");

	Params::GT_Bodycam_C_Find_Best_Spawn_Point Parms{};

	Parms.PCInfo = std::move(PCInfo);

	UObject::ProcessEvent(Func, &Parms);

	if (FarestTransform_return != nullptr)
		*FarestTransform_return = std::move(Parms.FarestTransform_return);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;
}


// Function GT_Bodycam.GT_Bodycam_C.Get BP Menu Controller Component
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MenuControllerComponent_C**   BP_Menu_Controller_Component                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Get_BP_Menu_Controller_Component(class UBP_MenuControllerComponent_C** BP_Menu_Controller_Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Get BP Menu Controller Component");

	Params::GT_Bodycam_C_Get_BP_Menu_Controller_Component Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BP_Menu_Controller_Component != nullptr)
		*BP_Menu_Controller_Component = Parms.BP_Menu_Controller_Component;
}


// Function GT_Bodycam.GT_Bodycam_C.Get Stamina
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 Stamina                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Get_Stamina(double* Stamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Get Stamina");

	Params::GT_Bodycam_C_Get_Stamina Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Stamina != nullptr)
		*Stamina = Parms.Stamina;
}


// Function GT_Bodycam.GT_Bodycam_C.GetAllowedMap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSoftObjectPtr<class UPDA_LevelMetaData_C>>*AllowedMap                                             (Parm, OutParm)

void AGT_Bodycam_C::GetAllowedMap(TArray<TSoftObjectPtr<class UPDA_LevelMetaData_C>>* AllowedMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetAllowedMap");

	Params::GT_Bodycam_C_GetAllowedMap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllowedMap != nullptr)
		*AllowedMap = std::move(Parms.AllowedMap);
}


// Function GT_Bodycam.GT_Bodycam_C.GetBlured
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 Blured                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetBlured(double* Blured)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetBlured");

	Params::GT_Bodycam_C_GetBlured Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Blured != nullptr)
		*Blured = Parms.Blured;
}


// Function GT_Bodycam.GT_Bodycam_C.GetBotsAccuracy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector*                         TargetLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 CurrentAccuracy                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 BotSkillThreshold                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   TargetIsPlayer                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetBotsAccuracy(struct FVector* TargetLocation, double* CurrentAccuracy, double* BotSkillThreshold, bool* TargetIsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetBotsAccuracy");

	Params::GT_Bodycam_C_GetBotsAccuracy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TargetLocation != nullptr)
		*TargetLocation = std::move(Parms.TargetLocation);

	if (CurrentAccuracy != nullptr)
		*CurrentAccuracy = Parms.CurrentAccuracy;

	if (BotSkillThreshold != nullptr)
		*BotSkillThreshold = Parms.BotSkillThreshold;

	if (TargetIsPlayer != nullptr)
		*TargetIsPlayer = Parms.TargetIsPlayer;
}


// Function GT_Bodycam.GT_Bodycam_C.GetBurnedRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent**                 BurnedMesh                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetBurnedRef(class USceneComponent** BurnedMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetBurnedRef");

	Params::GT_Bodycam_C_GetBurnedRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BurnedMesh != nullptr)
		*BurnedMesh = Parms.BurnedMesh;
}


// Function GT_Bodycam.GT_Bodycam_C.GetCurrentWeaponsGunGame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName*                            CurrentWeaponsGunGame                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetCurrentWeaponsGunGame(class FName* CurrentWeaponsGunGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetCurrentWeaponsGunGame");

	Params::GT_Bodycam_C_GetCurrentWeaponsGunGame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentWeaponsGunGame != nullptr)
		*CurrentWeaponsGunGame = Parms.CurrentWeaponsGunGame;
}


// Function GT_Bodycam.GT_Bodycam_C.GetDeadView
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent**                CameraComponent                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetDeadView(class UCameraComponent** CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetDeadView");

	Params::GT_Bodycam_C_GetDeadView Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CameraComponent != nullptr)
		*CameraComponent = Parms.CameraComponent;
}


// Function GT_Bodycam.GT_Bodycam_C.GetFlashBangEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 FlashEffect                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetFlashBangEffect(double* FlashEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetFlashBangEffect");

	Params::GT_Bodycam_C_GetFlashBangEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FlashEffect != nullptr)
		*FlashEffect = Parms.FlashEffect;
}


// Function GT_Bodycam.GT_Bodycam_C.GetGameMode
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTR_GamemodeWinInfo*            GameMode_0                                             (Parm, OutParm, HasGetValueTypeHash)

void AGT_Bodycam_C::GetGameMode(struct FSTR_GamemodeWinInfo* GameMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetGameMode");

	Params::GT_Bodycam_C_GetGameMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (GameMode_0 != nullptr)
		*GameMode_0 = std::move(Parms.GameMode_0);
}


// Function GT_Bodycam.GT_Bodycam_C.GetGamemodeInfo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FSTR_GamemodeWinInfo*            GamemodeInfo_0                                         (Parm, OutParm, HasGetValueTypeHash)

void AGT_Bodycam_C::GetGamemodeInfo(struct FSTR_GamemodeWinInfo* GamemodeInfo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetGamemodeInfo");

	Params::GT_Bodycam_C_GetGamemodeInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (GamemodeInfo_0 != nullptr)
		*GamemodeInfo_0 = std::move(Parms.GamemodeInfo_0);
}


// Function GT_Bodycam.GT_Bodycam_C.GetHealth
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 Health                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetHealth(double* Health)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetHealth");

	Params::GT_Bodycam_C_GetHealth Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Health != nullptr)
		*Health = Parms.Health;
}


// Function GT_Bodycam.GT_Bodycam_C.GetKickedPlayerVoted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>*                  KickplayerAlreadyVote                                  (Parm, OutParm)

void AGT_Bodycam_C::GetKickedPlayerVoted(TArray<class FString>* KickplayerAlreadyVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetKickedPlayerVoted");

	Params::GT_Bodycam_C_GetKickedPlayerVoted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (KickplayerAlreadyVote != nullptr)
		*KickplayerAlreadyVote = std::move(Parms.KickplayerAlreadyVote);
}


// Function GT_Bodycam.GT_Bodycam_C.GetMapVotersPlayerID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FString&                    LevelName                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
// TArray<struct FSTR_VoteNextMapInfo>*    VoterId_Return                                         (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::GetMapVotersPlayerID(const class FString& LevelName, TArray<struct FSTR_VoteNextMapInfo>* VoterId_Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetMapVotersPlayerID");

	Params::GT_Bodycam_C_GetMapVotersPlayerID Parms{};

	Parms.LevelName = std::move(LevelName);

	UObject::ProcessEvent(Func, &Parms);

	if (VoterId_Return != nullptr)
		*VoterId_Return = std::move(Parms.VoterId_Return);
}


// Function GT_Bodycam.GT_Bodycam_C.GetMenuSettings
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MenuControllerComponent_C**   Bp_MenuController                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetMenuSettings(class UBP_MenuControllerComponent_C** Bp_MenuController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetMenuSettings");

	Params::GT_Bodycam_C_GetMenuSettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Bp_MenuController != nullptr)
		*Bp_MenuController = Parms.Bp_MenuController;
}


// Function GT_Bodycam.GT_Bodycam_C.GetMostVotedMap
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString*                          MostVotedMap                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetMostVotedMap(class FString* MostVotedMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetMostVotedMap");

	Params::GT_Bodycam_C_GetMostVotedMap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MostVotedMap != nullptr)
		*MostVotedMap = std::move(Parms.MostVotedMap);
}


// Function GT_Bodycam.GT_Bodycam_C.GetMutePlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>*                  MutePlayer                                             (Parm, OutParm)

void AGT_Bodycam_C::GetMutePlayer(TArray<class FString>* MutePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetMutePlayer");

	Params::GT_Bodycam_C_GetMutePlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MutePlayer != nullptr)
		*MutePlayer = std::move(Parms.MutePlayer);
}


// Function GT_Bodycam.GT_Bodycam_C.GetPcInfo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTR_PCInfo*                     PCInfo                                                 (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::GetPcInfo(struct FSTR_PCInfo* PCInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetPcInfo");

	Params::GT_Bodycam_C_GetPcInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PCInfo != nullptr)
		*PCInfo = std::move(Parms.PCInfo);
}


// Function GT_Bodycam.GT_Bodycam_C.GetPlayerConnected
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSTR_PCInfo>*             PlayerConnected                                        (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::GetPlayerConnected(TArray<struct FSTR_PCInfo>* PlayerConnected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetPlayerConnected");

	Params::GT_Bodycam_C_GetPlayerConnected Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerConnected != nullptr)
		*PlayerConnected = std::move(Parms.PlayerConnected);
}


// Function GT_Bodycam.GT_Bodycam_C.GetPlayerKickVote
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSTR_KickVote>*           KickVotePlayer                                         (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::GetPlayerKickVote(TArray<struct FSTR_KickVote>* KickVotePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetPlayerKickVote");

	Params::GT_Bodycam_C_GetPlayerKickVote Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (KickVotePlayer != nullptr)
		*KickVotePlayer = std::move(Parms.KickVotePlayer);
}


// Function GT_Bodycam.GT_Bodycam_C.GetPlayerSkin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTR_TEST*                       Player_Skin                                            (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Valid_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetPlayerSkin(struct FSTR_TEST* Player_Skin, bool* Valid_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetPlayerSkin");

	Params::GT_Bodycam_C_GetPlayerSkin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Player_Skin != nullptr)
		*Player_Skin = std::move(Parms.Player_Skin);

	if (Valid_ != nullptr)
		*Valid_ = Parms.Valid_;
}


// Function GT_Bodycam.GT_Bodycam_C.GetRagdollSystem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWW_RagdollSystem_C**             Ragdoll_System                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetRagdollSystem(class UWW_RagdollSystem_C** Ragdoll_System)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetRagdollSystem");

	Params::GT_Bodycam_C_GetRagdollSystem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ragdoll_System != nullptr)
		*Ragdoll_System = Parms.Ragdoll_System;
}


// Function GT_Bodycam.GT_Bodycam_C.GetReady?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsReady_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetReady_(bool* IsReady_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetReady?");

	Params::GT_Bodycam_C_GetReady_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsReady_ != nullptr)
		*IsReady_ = Parms.IsReady_;
}


// Function GT_Bodycam.GT_Bodycam_C.GetReloadPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetReloadPlayRate(double* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetReloadPlayRate");

	Params::GT_Bodycam_C_GetReloadPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function GT_Bodycam.GT_Bodycam_C.GetServerSteamID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString*                          SteamID                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetServerSteamID(class FString* SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetServerSteamID");

	Params::GT_Bodycam_C_GetServerSteamID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SteamID != nullptr)
		*SteamID = std::move(Parms.SteamID);
}


// Function GT_Bodycam.GT_Bodycam_C.GetStarterWeapons
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSTR_Loadout>*            Weapons                                                (Parm, OutParm)

void AGT_Bodycam_C::GetStarterWeapons(TArray<struct FSTR_Loadout>* Weapons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetStarterWeapons");

	Params::GT_Bodycam_C_GetStarterWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weapons != nullptr)
		*Weapons = std::move(Parms.Weapons);
}


// Function GT_Bodycam.GT_Bodycam_C.GetSteamID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString*                          SteamID                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetSteamID(class FString* SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetSteamID");

	Params::GT_Bodycam_C_GetSteamID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SteamID != nullptr)
		*SteamID = std::move(Parms.SteamID);
}


// Function GT_Bodycam.GT_Bodycam_C.GetSurvivorStatuts
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWW_SurvivorStatus_C**            SurvivorComponant                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetSurvivorStatuts(class UWW_SurvivorStatus_C** SurvivorComponant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetSurvivorStatuts");

	Params::GT_Bodycam_C_GetSurvivorStatuts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SurvivorComponant != nullptr)
		*SurvivorComponant = Parms.SurvivorComponant;
}


// Function GT_Bodycam.GT_Bodycam_C.GetTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Team*                                 Team                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetTeam(E_Team* Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetTeam");

	Params::GT_Bodycam_C_GetTeam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Team != nullptr)
		*Team = Parms.Team;
}


// Function GT_Bodycam.GT_Bodycam_C.GetTeamList
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Team                                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSTR_PCInfo>*             Info                                                   (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::GetTeamList(E_Team Team, TArray<struct FSTR_PCInfo>* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetTeamList");

	Params::GT_Bodycam_C_GetTeamList Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GT_Bodycam.GT_Bodycam_C.GetTopScore
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSTR_PCInfo>*             TopScore                                               (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::GetTopScore(TArray<struct FSTR_PCInfo>* TopScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetTopScore");

	Params::GT_Bodycam_C_GetTopScore Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TopScore != nullptr)
		*TopScore = std::move(Parms.TopScore);
}


// Function GT_Bodycam.GT_Bodycam_C.GetWep
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AWEP_C**                          WEP                                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::GetWep(class AWEP_C** WEP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GetWep");

	Params::GT_Bodycam_C_GetWep Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (WEP != nullptr)
		*WEP = Parms.WEP;
}


// Function GT_Bodycam.GT_Bodycam_C.GlobalUpdate (HUD_PC)
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::GlobalUpdate__HUD_PC_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "GlobalUpdate (HUD_PC)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Index Team Alive
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  IndexMilitaryAlive_Return                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  IndexTerroristAlive_Return                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSTR_PCInfo>*             MilitaryTeam_Return                                    (Parm, OutParm, ContainsInstancedReference)
// TArray<struct FSTR_PCInfo>*             TerroristTeam_Return                                   (Parm, OutParm, ContainsInstancedReference)
// E_Team*                                 DominantAliveTeam                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Index_Team_Alive(int32* IndexMilitaryAlive_Return, int32* IndexTerroristAlive_Return, TArray<struct FSTR_PCInfo>* MilitaryTeam_Return, TArray<struct FSTR_PCInfo>* TerroristTeam_Return, E_Team* DominantAliveTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Index Team Alive");

	Params::GT_Bodycam_C_Index_Team_Alive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IndexMilitaryAlive_Return != nullptr)
		*IndexMilitaryAlive_Return = Parms.IndexMilitaryAlive_Return;

	if (IndexTerroristAlive_Return != nullptr)
		*IndexTerroristAlive_Return = Parms.IndexTerroristAlive_Return;

	if (MilitaryTeam_Return != nullptr)
		*MilitaryTeam_Return = std::move(Parms.MilitaryTeam_Return);

	if (TerroristTeam_Return != nullptr)
		*TerroristTeam_Return = std::move(Parms.TerroristTeam_Return);

	if (DominantAliveTeam != nullptr)
		*DominantAliveTeam = Parms.DominantAliveTeam;
}


// Function GT_Bodycam.GT_Bodycam_C.InitScoreBoard
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::InitScoreBoard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "InitScoreBoard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.InitVoteNextMap
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::InitVoteNextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "InitVoteNextMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.IntroMatch
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::IntroMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IntroMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Is Match Point?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Is_Match_Point__0                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Is_Match_Point_(bool* Is_Match_Point__0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Is Match Point?");

	Params::GT_Bodycam_C_Is_Match_Point_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Is_Match_Point__0 != nullptr)
		*Is_Match_Point__0 = Parms.Is_Match_Point__0;
}


// Function GT_Bodycam.GT_Bodycam_C.Is Player Already Voted Map ?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FSTR_VoteNextMapInfo&      PlayerVote                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool*                                   Yes_                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  VoteIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Is_Player_Already_Voted_Map__(const struct FSTR_VoteNextMapInfo& PlayerVote, bool* Yes_, int32* VoteIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Is Player Already Voted Map ?");

	Params::GT_Bodycam_C_Is_Player_Already_Voted_Map__ Parms{};

	Parms.PlayerVote = std::move(PlayerVote);

	UObject::ProcessEvent(Func, &Parms);

	if (Yes_ != nullptr)
		*Yes_ = Parms.Yes_;

	if (VoteIndex != nullptr)
		*VoteIndex = Parms.VoteIndex;
}


// Function GT_Bodycam.GT_Bodycam_C.Is Spawn Point Valid
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FTransform&                Spawn_Transform                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Valid_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Is_Spawn_Point_Valid(const struct FTransform& Spawn_Transform, bool* Valid_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Is Spawn Point Valid");

	Params::GT_Bodycam_C_Is_Spawn_Point_Valid Parms{};

	Parms.Spawn_Transform = std::move(Spawn_Transform);

	UObject::ProcessEvent(Func, &Parms);

	if (Valid_ != nullptr)
		*Valid_ = Parms.Valid_;
}


// Function GT_Bodycam.GT_Bodycam_C.IsDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Dead_                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::IsDead(bool* Dead_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IsDead");

	Params::GT_Bodycam_C_IsDead Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dead_ != nullptr)
		*Dead_ = Parms.Dead_;
}


// Function GT_Bodycam.GT_Bodycam_C.IsDestroyabe?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Destroyable_                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::IsDestroyabe_(bool* Destroyable_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IsDestroyabe?");

	Params::GT_Bodycam_C_IsDestroyabe_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Destroyable_ != nullptr)
		*Destroyable_ = Parms.Destroyable_;
}


// Function GT_Bodycam.GT_Bodycam_C.IsPlayerWinning
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Yes_                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::IsPlayerWinning(bool* Yes_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IsPlayerWinning");

	Params::GT_Bodycam_C_IsPlayerWinning Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Yes_ != nullptr)
		*Yes_ = Parms.Yes_;
}


// Function GT_Bodycam.GT_Bodycam_C.IsReady?
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsReady__0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::IsReady_(bool IsReady__0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IsReady?");

	Params::GT_Bodycam_C_IsReady_ Parms{};

	Parms.IsReady__0 = IsReady__0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.IsStress
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Yes_                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::IsStress(bool* Yes_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IsStress");

	Params::GT_Bodycam_C_IsStress Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Yes_ != nullptr)
		*Yes_ = Parms.Yes_;
}


// Function GT_Bodycam.GT_Bodycam_C.IsTalking?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsTalking__0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::IsTalking_(bool* IsTalking__0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "IsTalking?");

	Params::GT_Bodycam_C_IsTalking_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsTalking__0 != nullptr)
		*IsTalking__0 = Parms.IsTalking__0;
}


// Function GT_Bodycam.GT_Bodycam_C.Kick?
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::Kick_(const struct FSTR_PCInfo& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Kick?");

	Params::GT_Bodycam_C_Kick_ Parms{};

	Parms.Target = std::move(Target);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Kick? (Server)
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               PlayerInfo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::Kick___Server_(const struct FSTR_PCInfo& PlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Kick? (Server)");

	Params::GT_Bodycam_C_Kick___Server_ Parms{};

	Parms.PlayerInfo = std::move(PlayerInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.KickPlayer
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_KickVote&             PlayerInfo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::KickPlayer(const struct FSTR_KickVote& PlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "KickPlayer");

	Params::GT_Bodycam_C_KickPlayer Parms{};

	Parms.PlayerInfo = std::move(PlayerInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.KickPlayer (Server)
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_KickVote&             NewItem                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::KickPlayer__Server_(const struct FSTR_KickVote& NewItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "KickPlayer (Server)");

	Params::GT_Bodycam_C_KickPlayer__Server_ Parms{};

	Parms.NewItem = std::move(NewItem);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Kill List Info
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSTR_KillInfo>&           KillList                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32*                                  KillIndexReturn                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TeamKillIndexReturn                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Kill_List_Info(TArray<struct FSTR_KillInfo>& KillList, int32* KillIndexReturn, int32* TeamKillIndexReturn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Kill List Info");

	Params::GT_Bodycam_C_Kill_List_Info Parms{};

	Parms.KillList = std::move(KillList);

	UObject::ProcessEvent(Func, &Parms);

	KillList = std::move(Parms.KillList);

	if (KillIndexReturn != nullptr)
		*KillIndexReturn = Parms.KillIndexReturn;

	if (TeamKillIndexReturn != nullptr)
		*TeamKillIndexReturn = Parms.TeamKillIndexReturn;
}


// Function GT_Bodycam.GT_Bodycam_C.MatchBeginTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::MatchBeginTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "MatchBeginTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Multicast - CommunicateServerTravel
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Multicast___CommunicateServerTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Multicast - CommunicateServerTravel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.MuteID
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    SteamID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::MuteID(const class FString& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "MuteID");

	Params::GT_Bodycam_C_MuteID Parms{};

	Parms.SteamID = std::move(SteamID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.NewKickVote
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::NewKickVote(const struct FSTR_PCInfo& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "NewKickVote");

	Params::GT_Bodycam_C_NewKickVote Parms{};

	Parms.Target = std::move(Target);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Not Enough Player To Play
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   NotEnoughPlayer_                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Not_Enough_Player_To_Play(bool* NotEnoughPlayer_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Not Enough Player To Play");

	Params::GT_Bodycam_C_Not_Enough_Player_To_Play Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NotEnoughPlayer_ != nullptr)
		*NotEnoughPlayer_ = Parms.NotEnoughPlayer_;
}


// Function GT_Bodycam.GT_Bodycam_C.OnFailure_CF1F22D2456BC42D0080E898B344F08A
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnFailure_CF1F22D2456BC42D0080E898B344F08A()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnFailure_CF1F22D2456BC42D0080E898B344F08A");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnPlayerDeath
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               PC                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::OnPlayerDeath(const struct FSTR_PCInfo& PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnPlayerDeath");

	Params::GT_Bodycam_C_OnPlayerDeath Parms{};

	Parms.PC = std::move(PC);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.OnRep_GM_statue
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnRep_GM_statue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnRep_GM_statue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnRep_PlayerMiss
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnRep_PlayerMiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnRep_PlayerMiss");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnRep_PrimaryScope
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnRep_PrimaryScope()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnRep_PrimaryScope");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnRep_SecondaryScope
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnRep_SecondaryScope()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnRep_SecondaryScope");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnRep_VoteMapTimer
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnRep_VoteMapTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnRep_VoteMapTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnSuccess_CF1F22D2456BC42D0080E898B344F08A
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::OnSuccess_CF1F22D2456BC42D0080E898B344F08A()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnSuccess_CF1F22D2456BC42D0080E898B344F08A");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.OnTrySelectTeam
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Team                                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::OnTrySelectTeam(E_Team Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OnTrySelectTeam");

	Params::GT_Bodycam_C_OnTrySelectTeam Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.OppositeTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team                                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Team*                                 OppositeTeam_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::OppositeTeam(E_Team Team, E_Team* OppositeTeam_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "OppositeTeam");

	Params::GT_Bodycam_C_OppositeTeam Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);

	if (OppositeTeam_0 != nullptr)
		*OppositeTeam_0 = Parms.OppositeTeam_0;
}


// Function GT_Bodycam.GT_Bodycam_C.Pause Match Timer
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Pause_Match_Timer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Pause Match Timer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Stop End Round Sound (Multicast)
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Stop_                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Stop_End_Round_Sound__Multicast_(bool Stop_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Stop End Round Sound (Multicast)");

	Params::GT_Bodycam_C_Stop_End_Round_Sound__Multicast_ Parms{};

	Parms.Stop_ = Stop_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.PlayerWaitedArray
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSTR_PCInfo>*             PlayerWaited_Return                                    (Parm, OutParm, ContainsInstancedReference)
// class FString*                          PlayerSteamName_Return                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::PlayerWaitedArray(TArray<struct FSTR_PCInfo>* PlayerWaited_Return, class FString* PlayerSteamName_Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "PlayerWaitedArray");

	Params::GT_Bodycam_C_PlayerWaitedArray Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerWaited_Return != nullptr)
		*PlayerWaited_Return = std::move(Parms.PlayerWaited_Return);

	if (PlayerSteamName_Return != nullptr)
		*PlayerSteamName_Return = std::move(Parms.PlayerSteamName_Return);
}


// Function GT_Bodycam.GT_Bodycam_C.PlaySoundLocal
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        Audio                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::PlaySoundLocal(class USoundCue* Audio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "PlaySoundLocal");

	Params::GT_Bodycam_C_PlaySoundLocal Parms{};

	Parms.Audio = Audio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.RandomStuff
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::RandomStuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "RandomStuff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AGT_Bodycam_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.RefreshMapVoterPlayerID
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::RefreshMapVoterPlayerID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "RefreshMapVoterPlayerID");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.RefreshMapVoterPlayerID (Mutlicast)
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSTR_VoteNextMapInfo>&    PlayerVoteNextMapList_0                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void AGT_Bodycam_C::RefreshMapVoterPlayerID__Mutlicast_(TArray<struct FSTR_VoteNextMapInfo>& PlayerVoteNextMapList_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "RefreshMapVoterPlayerID (Mutlicast)");

	Params::GT_Bodycam_C_RefreshMapVoterPlayerID__Mutlicast_ Parms{};

	Parms.PlayerVoteNextMapList_0 = std::move(PlayerVoteNextMapList_0);

	UObject::ProcessEvent(Func, &Parms);

	PlayerVoteNextMapList_0 = std::move(Parms.PlayerVoteNextMapList_0);
}


// Function GT_Bodycam.GT_Bodycam_C.RefreshScoreBoard
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::RefreshScoreBoard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "RefreshScoreBoard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.ResetIntroTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::ResetIntroTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ResetIntroTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Respawn
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSTR_PCInfo&               Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void AGT_Bodycam_C::Respawn(double duration, const struct FSTR_PCInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Respawn");

	Params::GT_Bodycam_C_Respawn Parms{};

	Parms.duration = duration;
	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.SelectTeam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team                                  FriendTeam                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlayerAsking                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Team                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

E_Team AGT_Bodycam_C::SelectTeam(E_Team FriendTeam, bool IsPlayerAsking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "SelectTeam");

	Params::GT_Bodycam_C_SelectTeam Parms{};

	Parms.FriendTeam = FriendTeam;
	Parms.IsPlayerAsking = IsPlayerAsking;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GT_Bodycam.GT_Bodycam_C.ServerSteamID (Server)
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::ServerSteamID__Server_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ServerSteamID (Server)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.ServerTravel
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::ServerTravel(double Delay, const class FString& Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ServerTravel");

	Params::GT_Bodycam_C_ServerTravel Parms{};

	Parms.Delay = Delay;
	Parms.Level = std::move(Level);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.ServerTravel (Multicast)
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::ServerTravel__Multicast_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ServerTravel (Multicast)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.ServerTravel (server)
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::ServerTravel__server_(float duration, const class FString& Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "ServerTravel (server)");

	Params::GT_Bodycam_C_ServerTravel__server_ Parms{};

	Parms.duration = duration;
	Parms.Level = std::move(Level);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Set Bomb
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class ABombe_C>          Bomb_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AGT_Bodycam_C::Set_Bomb(TSoftObjectPtr<class ABombe_C> Bomb_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Set Bomb");

	Params::GT_Bodycam_C_Set_Bomb Parms{};

	Parms.Bomb_0 = Bomb_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Slomo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Slomo_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Slomo(double Slomo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Slomo");

	Params::GT_Bodycam_C_Slomo Parms{};

	Parms.Slomo_0 = Slomo_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Slomo (multicast)
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Slomo__multicast_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Slomo (multicast)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.SlomoCurve__FinishedFunc
// (BlueprintEvent)

void AGT_Bodycam_C::SlomoCurve__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "SlomoCurve__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.SlomoCurve__UpdateFunc
// (BlueprintEvent)

void AGT_Bodycam_C::SlomoCurve__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "SlomoCurve__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.SpawnUI
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::SpawnUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "SpawnUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.SpawnVoteNextMap(Hud)
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::SpawnVoteNextMap_Hud_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "SpawnVoteNextMap(Hud)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.SpawnWinHud (server)
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::SpawnWinHud__server_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "SpawnWinHud (server)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.StartingWeapons
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::StartingWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "StartingWeapons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.StartMatch
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::StartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "StartMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Talk
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsTalking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Talk(bool IsTalking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Talk");

	Params::GT_Bodycam_C_Talk Parms{};

	Parms.IsTalking = IsTalking;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.TeamAlive?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team                                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  AlivesIndex_Return                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   TeamAllDead                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::TeamAlive_(E_Team Team, int32* AlivesIndex_Return, bool* TeamAllDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamAlive?");

	Params::GT_Bodycam_C_TeamAlive_ Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);

	if (AlivesIndex_Return != nullptr)
		*AlivesIndex_Return = Parms.AlivesIndex_Return;

	if (TeamAllDead != nullptr)
		*TeamAllDead = Parms.TeamAllDead;
}


// Function GT_Bodycam.GT_Bodycam_C.TeamFull?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team                                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlayerAsking                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Full_                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::TeamFull_(E_Team Team, bool IsPlayerAsking, bool* Full_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamFull?");

	Params::GT_Bodycam_C_TeamFull_ Parms{};

	Parms.Team = Team;
	Parms.IsPlayerAsking = IsPlayerAsking;

	UObject::ProcessEvent(Func, &Parms);

	if (Full_ != nullptr)
		*Full_ = Parms.Full_;
}


// Function GT_Bodycam.GT_Bodycam_C.TeamHasBomb
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team*                                 Team_Has_Bomb                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::TeamHasBomb(E_Team* Team_Has_Bomb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamHasBomb");

	Params::GT_Bodycam_C_TeamHasBomb Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Team_Has_Bomb != nullptr)
		*Team_Has_Bomb = Parms.Team_Has_Bomb;
}


// Function GT_Bodycam.GT_Bodycam_C.TeamHasBombArray
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSTR_PCInfo>*             Team_Has_Bomb_Return                                   (Parm, OutParm, ContainsInstancedReference)
// TArray<struct FSTR_PCInfo>*             Other_Team_Return                                      (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::TeamHasBombArray(TArray<struct FSTR_PCInfo>* Team_Has_Bomb_Return, TArray<struct FSTR_PCInfo>* Other_Team_Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamHasBombArray");

	Params::GT_Bodycam_C_TeamHasBombArray Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Team_Has_Bomb_Return != nullptr)
		*Team_Has_Bomb_Return = std::move(Parms.Team_Has_Bomb_Return);

	if (Other_Team_Return != nullptr)
		*Other_Team_Return = std::move(Parms.Other_Team_Return);
}


// Function GT_Bodycam.GT_Bodycam_C.TeamHaveBestScore
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team*                                 WinningTeamEnumReturn                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSTR_PCInfo>*             WinningTeam_Return                                     (Parm, OutParm, ContainsInstancedReference)
// TArray<struct FSTR_PCInfo>*             LoosingTeam_Return                                     (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::TeamHaveBestScore(E_Team* WinningTeamEnumReturn, TArray<struct FSTR_PCInfo>* WinningTeam_Return, TArray<struct FSTR_PCInfo>* LoosingTeam_Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamHaveBestScore");

	Params::GT_Bodycam_C_TeamHaveBestScore Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (WinningTeamEnumReturn != nullptr)
		*WinningTeamEnumReturn = Parms.WinningTeamEnumReturn;

	if (WinningTeam_Return != nullptr)
		*WinningTeam_Return = std::move(Parms.WinningTeam_Return);

	if (LoosingTeam_Return != nullptr)
		*LoosingTeam_Return = std::move(Parms.LoosingTeam_Return);
}


// Function GT_Bodycam.GT_Bodycam_C.TeamIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  NoneIndex_Return                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  MilitaryIndex_Return                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TerroristIndex_Return                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Team*                                 TeamNeedPlayer                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   TeamEmpty_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSTR_PCInfo>*             Military_Return                                        (Parm, OutParm, ContainsInstancedReference)
// TArray<struct FSTR_PCInfo>*             Terrorist_Return                                       (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::TeamIndex(int32* NoneIndex_Return, int32* MilitaryIndex_Return, int32* TerroristIndex_Return, E_Team* TeamNeedPlayer, bool* TeamEmpty_, TArray<struct FSTR_PCInfo>* Military_Return, TArray<struct FSTR_PCInfo>* Terrorist_Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamIndex");

	Params::GT_Bodycam_C_TeamIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoneIndex_Return != nullptr)
		*NoneIndex_Return = Parms.NoneIndex_Return;

	if (MilitaryIndex_Return != nullptr)
		*MilitaryIndex_Return = Parms.MilitaryIndex_Return;

	if (TerroristIndex_Return != nullptr)
		*TerroristIndex_Return = Parms.TerroristIndex_Return;

	if (TeamNeedPlayer != nullptr)
		*TeamNeedPlayer = Parms.TeamNeedPlayer;

	if (TeamEmpty_ != nullptr)
		*TeamEmpty_ = Parms.TeamEmpty_;

	if (Military_Return != nullptr)
		*Military_Return = std::move(Parms.Military_Return);

	if (Terrorist_Return != nullptr)
		*Terrorist_Return = std::move(Parms.Terrorist_Return);
}


// Function GT_Bodycam.GT_Bodycam_C.Teams Score Are Null?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   FirstRound_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Teams_Score_Are_Null_(bool* FirstRound_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Teams Score Are Null?");

	Params::GT_Bodycam_C_Teams_Score_Are_Null_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FirstRound_0 != nullptr)
		*FirstRound_0 = Parms.FirstRound_0;
}


// Function GT_Bodycam.GT_Bodycam_C.TeamScore
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Team                                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Score                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::TeamScore(E_Team Team, int32* Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TeamScore");

	Params::GT_Bodycam_C_TeamScore Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);

	if (Score != nullptr)
		*Score = Parms.Score;
}


// Function GT_Bodycam.GT_Bodycam_C.TimerSounds
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Timer                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::TimerSounds(double Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TimerSounds");

	Params::GT_Bodycam_C_TimerSounds Parms{};

	Parms.Timer = Timer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.TopScore
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSTR_PCInfo>*             TopScorePcArray_Result                                 (Parm, OutParm, ContainsInstancedReference)

void AGT_Bodycam_C::TopScore(TArray<struct FSTR_PCInfo>* TopScorePcArray_Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TopScore");

	Params::GT_Bodycam_C_TopScore Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TopScorePcArray_Result != nullptr)
		*TopScorePcArray_Result = std::move(Parms.TopScorePcArray_Result);
}


// Function GT_Bodycam.GT_Bodycam_C.TryToStartMatch
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::TryToStartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "TryToStartMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Update MapSelection (Hud_MenuScoreboard)
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Selected_Level_Name                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Update_MapSelection__Hud_MenuScoreboard_(class FName Selected_Level_Name, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update MapSelection (Hud_MenuScoreboard)");

	Params::GT_Bodycam_C_Update_MapSelection__Hud_MenuScoreboard_ Parms{};

	Parms.Selected_Level_Name = Selected_Level_Name;
	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Update Match Timer 
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Update_Match_Timer_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update Match Timer ");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Update ModeInfo (HUD_PC)
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Update_ModeInfo__HUD_PC_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update ModeInfo (HUD_PC)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Update transition (Hud_Transition)
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Update_transition__Hud_Transition_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update transition (Hud_Transition)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Update Vote Timer Text
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  TimerIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Update_Vote_Timer_Text(double TimerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update Vote Timer Text");

	Params::GT_Bodycam_C_Update_Vote_Timer_Text Parms{};

	Parms.TimerIndex = TimerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.Update Waiting For Player (HUD_PC)
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::Update_Waiting_For_Player__HUD_PC_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update Waiting For Player (HUD_PC)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.Update Warning(Hud-Client)
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    InText                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::Update_Warning_Hud_Client_(const class FString& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "Update Warning(Hud-Client)");

	Params::GT_Bodycam_C_Update_Warning_Hud_Client_ Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateGamemode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EGameMode                               GameMode_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateGamemode(EGameMode GameMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateGamemode");

	Params::GT_Bodycam_C_UpdateGamemode Parms{};

	Parms.GameMode_0 = GameMode_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateKickVote
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Yes_                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateKickVote(const struct FSTR_PCInfo& Target, bool Yes_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateKickVote");

	Params::GT_Bodycam_C_UpdateKickVote Parms{};

	Parms.Target = std::move(Target);
	Parms.Yes_ = Yes_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateMapSelection
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Selected_Level_Name                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateMapSelection(class FName Selected_Level_Name, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateMapSelection");

	Params::GT_Bodycam_C_UpdateMapSelection Parms{};

	Parms.Selected_Level_Name = Selected_Level_Name;
	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateMapVoteTimerText
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Vote                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateMapVoteTimerText(double Vote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateMapVoteTimerText");

	Params::GT_Bodycam_C_UpdateMapVoteTimerText Parms{};

	Parms.Vote = Vote;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateModeInfo
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::UpdateModeInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateModeInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateScore
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_Score&                Score                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateScore(const struct FSTR_Score& Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateScore");

	Params::GT_Bodycam_C_UpdateScore Parms{};

	Parms.Score = std::move(Score);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateTeamXP
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Rpoints                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RanksPoints                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AccessReward_                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Winner_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateTeamXP(int32 Rpoints, int32 RanksPoints, bool AccessReward_, bool Winner_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateTeamXP");

	Params::GT_Bodycam_C_UpdateTeamXP Parms{};

	Parms.Rpoints = Rpoints;
	Parms.RanksPoints = RanksPoints;
	Parms.AccessReward_ = AccessReward_;
	Parms.Winner_ = Winner_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateTransitionMap
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::UpdateTransitionMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateTransitionMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateVote (Server)
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSTR_PCInfo&               Player_info                                            (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Yes_                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateVote__Server_(const struct FSTR_PCInfo& Player_info, bool Yes_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateVote (Server)");

	Params::GT_Bodycam_C_UpdateVote__Server_ Parms{};

	Parms.Player_info = std::move(Player_info);
	Parms.Yes_ = Yes_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateVoteMapTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::UpdateVoteMapTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateVoteMapTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GT_Bodycam.GT_Bodycam_C.UpdateWarning
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    String                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AGT_Bodycam_C::UpdateWarning(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "UpdateWarning");

	Params::GT_Bodycam_C_UpdateWarning Parms{};

	Parms.String = std::move(String);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GT_Bodycam.GT_Bodycam_C.WaitingForPlayer
// (BlueprintCallable, BlueprintEvent)

void AGT_Bodycam_C::WaitingForPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GT_Bodycam_C", "WaitingForPlayer");

	UObject::ProcessEvent(Func, nullptr);
}

}


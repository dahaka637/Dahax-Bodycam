#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MultiUserClientLibrary

#include "Basic.hpp"

#include "MultiUserClientLibrary_classes.hpp"
#include "MultiUserClientLibrary_parameters.hpp"


namespace SDK
{

// Function MultiUserClientLibrary.ChangeClientAsyncAction.ChangeClient
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGuid&                     ClientId_0                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiUserChangeClientReplicationRequest&Request                                                (Parm, NativeAccessSpecifierPublic)
// class UChangeClientAsyncAction*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChangeClientAsyncAction* UChangeClientAsyncAction::ChangeClient(const struct FGuid& ClientId_0, const struct FMultiUserChangeClientReplicationRequest& Request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ChangeClientAsyncAction", "ChangeClient");

	Params::ChangeClientAsyncAction_ChangeClient Parms{};

	Parms.ClientId_0 = std::move(ClientId_0);
	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationRegistration.DiscoverReplicationSettings
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FMultiUserReplicationRegistrationParams&Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IMultiUserReplicationRegistration::DiscoverReplicationSettings(const struct FMultiUserReplicationRegistrationParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MultiUserReplicationRegistration", "DiscoverReplicationSettings");

	Params::MultiUserReplicationRegistration_DiscoverReplicationSettings Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserReplicationRegistrationContext.AddAdditionalObject
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMultiUserReplicationRegistrationContext::AddAdditionalObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MultiUserReplicationRegistrationContext", "AddAdditionalObject");

	Params::MultiUserReplicationRegistrationContext_AddAdditionalObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserReplicationRegistrationContext.AddPropertiesToObject
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FConcertPropertyChainWrapper>&PropertiesToAdd                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void IMultiUserReplicationRegistrationContext::AddPropertiesToObject(class UObject* Object, const TArray<struct FConcertPropertyChainWrapper>& PropertiesToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MultiUserReplicationRegistrationContext", "AddPropertiesToObject");

	Params::MultiUserReplicationRegistrationContext_AddPropertiesToObject Parms{};

	Parms.Object = Object;
	Parms.PropertiesToAdd = std::move(PropertiesToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.ConfigureMultiUserClient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiUserClientConfig&    ClientConfig                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserClientStatics::ConfigureMultiUserClient(const struct FMultiUserClientConfig& ClientConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "ConfigureMultiUserClient");

	Params::MultiUserClientStatics_ConfigureMultiUserClient Parms{};

	Parms.ClientConfig = std::move(ClientConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GatherSessionChanges
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IgnorePersisted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UMultiUserClientStatics::GatherSessionChanges(bool IgnorePersisted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GatherSessionChanges");

	Params::MultiUserClientStatics_GatherSessionChanges Parms{};

	Parms.IgnorePersisted = IgnorePersisted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetConcertSyncDatabase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMultiUserClientSyncDatabase*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMultiUserClientSyncDatabase* UMultiUserClientStatics::GetConcertSyncDatabase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetConcertSyncDatabase");

	Params::MultiUserClientStatics_GetConcertSyncDatabase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetLastMultiUserConnectionError
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMultiUserConnectionError        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMultiUserConnectionError UMultiUserClientStatics::GetLastMultiUserConnectionError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetLastMultiUserConnectionError");

	Params::MultiUserClientStatics_GetLastMultiUserConnectionError Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetLocalMultiUserClientInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMultiUserClientInfo             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMultiUserClientInfo UMultiUserClientStatics::GetLocalMultiUserClientInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetLocalMultiUserClientInfo");

	Params::MultiUserClientStatics_GetLocalMultiUserClientInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetMultiUserClientInfoByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    ClientName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMultiUserClientInfo*            ClientInfo                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserClientStatics::GetMultiUserClientInfoByName(const class FString& ClientName, struct FMultiUserClientInfo* ClientInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetMultiUserClientInfoByName");

	Params::MultiUserClientStatics_GetMultiUserClientInfoByName Parms{};

	Parms.ClientName = std::move(ClientName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClientInfo != nullptr)
		*ClientInfo = std::move(Parms.ClientInfo);

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetMultiUserConnectionStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserClientStatics::GetMultiUserConnectionStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetMultiUserConnectionStatus");

	Params::MultiUserClientStatics_GetMultiUserConnectionStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetMultiUserConnectionStatusDetail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMultiUserConnectionStatus              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMultiUserConnectionStatus UMultiUserClientStatics::GetMultiUserConnectionStatusDetail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetMultiUserConnectionStatusDetail");

	Params::MultiUserClientStatics_GetMultiUserConnectionStatusDetail Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetMultiUserPresenceTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGuid&                     ClientEndpointId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UMultiUserClientStatics::GetMultiUserPresenceTransform(const struct FGuid& ClientEndpointId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetMultiUserPresenceTransform");

	Params::MultiUserClientStatics_GetMultiUserPresenceTransform Parms{};

	Parms.ClientEndpointId = std::move(ClientEndpointId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetMultiUserSessionInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMultiUserSessionInfo            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMultiUserSessionInfo UMultiUserClientStatics::GetMultiUserSessionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetMultiUserSessionInfo");

	Params::MultiUserClientStatics_GetMultiUserSessionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.GetRemoteMultiUserClientInfos
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FMultiUserClientInfo>*    ClientInfos                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserClientStatics::GetRemoteMultiUserClientInfos(TArray<struct FMultiUserClientInfo>* ClientInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "GetRemoteMultiUserClientInfos");

	Params::MultiUserClientStatics_GetRemoteMultiUserClientInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClientInfos != nullptr)
		*ClientInfos = std::move(Parms.ClientInfos);

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.JumpToMultiUserPresence
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    OtherUserName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                TransformOffset                                        (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserClientStatics::JumpToMultiUserPresence(const class FString& OtherUserName, const struct FTransform& TransformOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "JumpToMultiUserPresence");

	Params::MultiUserClientStatics_JumpToMultiUserPresence Parms{};

	Parms.OtherUserName = std::move(OtherUserName);
	Parms.TransformOffset = std::move(TransformOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.PersistMultiUserSessionChanges
// (Final, Native, Static, Public, BlueprintCallable)

void UMultiUserClientStatics::PersistMultiUserSessionChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "PersistMultiUserSessionChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.PersistSpecifiedPackages
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              PackagesToPersist                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMultiUserClientStatics::PersistSpecifiedPackages(const TArray<class FName>& PackagesToPersist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "PersistSpecifiedPackages");

	Params::MultiUserClientStatics_PersistSpecifiedPackages Parms{};

	Parms.PackagesToPersist = std::move(PackagesToPersist);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.SetMultiUserPresenceEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const bool                              IsEnabled                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserClientStatics::SetMultiUserPresenceEnabled(const bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "SetMultiUserPresenceEnabled");

	Params::MultiUserClientStatics_SetMultiUserPresenceEnabled Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.SetMultiUserPresenceVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PropagateToAll                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserClientStatics::SetMultiUserPresenceVisibility(const class FString& Name_0, bool Visibility, bool PropagateToAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "SetMultiUserPresenceVisibility");

	Params::MultiUserClientStatics_SetMultiUserPresenceVisibility Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Visibility = Visibility;
	Parms.PropagateToAll = PropagateToAll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.SetMultiUserPresenceVisibilityById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGuid&                     ClientEndpointId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PropagateToAll                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserClientStatics::SetMultiUserPresenceVisibilityById(const struct FGuid& ClientEndpointId, bool Visibility, bool PropagateToAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "SetMultiUserPresenceVisibilityById");

	Params::MultiUserClientStatics_SetMultiUserPresenceVisibilityById Parms{};

	Parms.ClientEndpointId = std::move(ClientEndpointId);
	Parms.Visibility = Visibility;
	Parms.PropagateToAll = PropagateToAll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.StartMultiUserDefaultConnection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserClientStatics::StartMultiUserDefaultConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "StartMultiUserDefaultConnection");

	Params::MultiUserClientStatics_StartMultiUserDefaultConnection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserClientStatics.UpdateWorkspaceModifiedPackages
// (Final, Native, Static, Public, BlueprintCallable)

void UMultiUserClientStatics::UpdateWorkspaceModifiedPackages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiUserClientStatics", "UpdateWorkspaceModifiedPackages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserReplicationRegistrationContextImpl.AddAdditionalObject
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserReplicationRegistrationContextImpl::AddAdditionalObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationRegistrationContextImpl", "AddAdditionalObject");

	Params::MultiUserReplicationRegistrationContextImpl_AddAdditionalObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserReplicationRegistrationContextImpl.AddPropertiesToObject
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FConcertPropertyChainWrapper>&PropertiesToAdd                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMultiUserReplicationRegistrationContextImpl::AddPropertiesToObject(class UObject* Object, const TArray<struct FConcertPropertyChainWrapper>& PropertiesToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationRegistrationContextImpl", "AddPropertiesToObject");

	Params::MultiUserReplicationRegistrationContextImpl_AddPropertiesToObject Parms{};

	Parms.Object = Object;
	Parms.PropertiesToAdd = std::move(PropertiesToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.GetObjectReplicationFrequency
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGuid&                     ClientId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           ObjectPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMultiUserObjectReplicationSettings*OutFrequency                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserReplicationSubsystem::GetObjectReplicationFrequency(const struct FGuid& ClientId, const struct FSoftObjectPath& ObjectPath, struct FMultiUserObjectReplicationSettings* OutFrequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "GetObjectReplicationFrequency");

	Params::MultiUserReplicationSubsystem_GetObjectReplicationFrequency Parms{};

	Parms.ClientId = std::move(ClientId);
	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFrequency != nullptr)
		*OutFrequency = std::move(Parms.OutFrequency);

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.GetOfflineClientIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGuid>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGuid> UMultiUserReplicationSubsystem::GetOfflineClientIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "GetOfflineClientIds");

	Params::MultiUserReplicationSubsystem_GetOfflineClientIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.GetOwningOfflineClients
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSoftObjectPath&           ObjectPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGuid>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGuid> UMultiUserReplicationSubsystem::GetOwningOfflineClients(const struct FSoftObjectPath& ObjectPath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "GetOwningOfflineClients");

	Params::MultiUserReplicationSubsystem_GetOwningOfflineClients Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.GetPropertiesRegisteredToObject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGuid&                     ClientId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           ObjectPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FConcertPropertyChainWrapper>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FConcertPropertyChainWrapper> UMultiUserReplicationSubsystem::GetPropertiesRegisteredToObject(const struct FGuid& ClientId, const struct FSoftObjectPath& ObjectPath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "GetPropertiesRegisteredToObject");

	Params::MultiUserReplicationSubsystem_GetPropertiesRegisteredToObject Parms{};

	Parms.ClientId = std::move(ClientId);
	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.GetRegisteredObjects
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGuid&                     ClientId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> UMultiUserReplicationSubsystem::GetRegisteredObjects(const struct FGuid& ClientId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "GetRegisteredObjects");

	Params::MultiUserReplicationSubsystem_GetRegisteredObjects Parms{};

	Parms.ClientId = std::move(ClientId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.GetReplicatedObjects
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGuid&                     ClientId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> UMultiUserReplicationSubsystem::GetReplicatedObjects(const struct FGuid& ClientId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "GetReplicatedObjects");

	Params::MultiUserReplicationSubsystem_GetReplicatedObjects Parms{};

	Parms.ClientId = std::move(ClientId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.IsOwnedByOfflineClient
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSoftObjectPath&           ObjectPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserReplicationSubsystem::IsOwnedByOfflineClient(const struct FSoftObjectPath& ObjectPath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "IsOwnedByOfflineClient");

	Params::MultiUserReplicationSubsystem_IsOwnedByOfflineClient Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserReplicationSubsystem.IsReplicatingObject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGuid&                     ClientId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           ObjectPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserReplicationSubsystem::IsReplicatingObject(const struct FGuid& ClientId, const struct FSoftObjectPath& ObjectPath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserReplicationSubsystem", "IsReplicatingObject");

	Params::MultiUserReplicationSubsystem_IsReplicatingObject Parms{};

	Parms.ClientId = std::move(ClientId);
	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.GetRemoteClientIds
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FGuid>*                   OutRemoteClientIds                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserSubsystem::GetRemoteClientIds(TArray<struct FGuid>* OutRemoteClientIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "GetRemoteClientIds");

	Params::MultiUserSubsystem_GetRemoteClientIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRemoteClientIds != nullptr)
		*OutRemoteClientIds = std::move(Parms.OutRemoteClientIds);

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.K2_ExtractEventData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMultiUserBlueprintEventData&    EventData                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32&                                  StructOut                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserSubsystem::K2_ExtractEventData(struct FMultiUserBlueprintEventData& EventData, int32& StructOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "K2_ExtractEventData");

	Params::MultiUserSubsystem_K2_ExtractEventData Parms{};

	Parms.EventData = std::move(EventData);
	Parms.StructOut = StructOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	EventData = std::move(Parms.EventData);
	StructOut = Parms.StructOut;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.K2_SendCustomEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32&                            EventData                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiUserSubsystem::K2_SendCustomEvent(const int32& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "K2_SendCustomEvent");

	Params::MultiUserSubsystem_K2_SendCustomEvent Parms{};

	Parms.EventData = EventData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.RegisterCustomEventHandler
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UStruct*                    EventType                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FMultiUserBlueprintEventData& Data)>InEventHandler                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserSubsystem::RegisterCustomEventHandler(const class UStruct* EventType, TDelegate<void(const struct FMultiUserBlueprintEventData& Data)> InEventHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "RegisterCustomEventHandler");

	Params::MultiUserSubsystem_RegisterCustomEventHandler Parms{};

	Parms.EventType = EventType;
	Parms.InEventHandler = InEventHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.UnregisterCustomEventHandler
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UStruct*                    EventType                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserSubsystem::UnregisterCustomEventHandler(const class UStruct* EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "UnregisterCustomEventHandler");

	Params::MultiUserSubsystem_UnregisterCustomEventHandler Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.GetLocalClientId
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid*                           OutClientId                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserSubsystem::GetLocalClientId(struct FGuid* OutClientId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "GetLocalClientId");

	Params::MultiUserSubsystem_GetLocalClientId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutClientId != nullptr)
		*OutClientId = std::move(Parms.OutClientId);

	return Parms.ReturnValue;
}


// Function MultiUserClientLibrary.MultiUserSubsystem.IsConnectedToSession
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiUserSubsystem::IsConnectedToSession() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiUserSubsystem", "IsConnectedToSession");

	Params::MultiUserSubsystem_IsConnectedToSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

